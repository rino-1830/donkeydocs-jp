# パスフォローテンプレート

パスフォローテンプレートはディープラーニングテンプレートの代替です。ディープラーニングテンプレートは屋内トラックのように照明条件や部屋の詳細を制御できる環境では優れていますが、照明条件が変化し環境が変わる屋外で動作させるのはより困難です。屋外ではGPSを利用できるため、`path_follow` テンプレートではGPSレシーバーで経路を記録し、その経路をたどる自動操縦を設定できます。

GPSの位置はGPSレシーバーからシリアルポート経由で読み取ります。これらはNMEAセンテンスとして読み込みます。NMEAは多くのGPSレシーバーがデフォルトで使用する行指向プロトコルです。NMEAセンテンスには緯度と経度の位置情報が含まれており、それらをメートル単位のローカル座標系に変換します。

経路を記録する際には、GPSレシーバーから取得した各 (x, y) 座標ペア（各ウェイポイント）をメモリ上の配列に保存します。その後、1行に1組の (x, y) 座標ペアがあるCSVファイルに保存できます。後でこのCSVファイルをメモリに読み込めば、ウェイポイントを読み込んだ状態で自動操縦モードに入り、そのポイント群をたどることができます。

ディープラーニングテンプレートと同様に、動作モードは3種類あります。

- **User** ドライブモードでは車を手動で操作します。ディープラーニングテンプレートと同様に、ウェブコントローラやゲームコントローラを使ってステアリングやスロットルを操作し、ボタンでアクションを選択できます。
- **Autosteering** モードでは、記録されたウェイポイント群に沿って車がステアリングのみを制御して走行します。スロットルは手動操作のままです。経路追従を始めるときに安全に止められるので、このモードから始めると良いでしょう。また、車がウェイポイントを確実にたどれる最高速度を知るのにも役立ちます。
- **Autopilot** モードでは、記録されたウェイポイント群に沿ってステアリングとスロットルの両方を制御しながら走行します。完全に自律走行です。停止するには、コントローラでUserモードを終了します。

<div class="video-container" align="center">
    <iframe class="video" width="560" height="315" src="https://www.youtube.com/embed/tjWmrCIKgnE" allowfullscreen></iframe>
<p>Path Follow Autopilot in Action</p>
  </div><br/>


経路を記録したり追従したりする前に、アプリケーションを作成して少し設定を行う必要があります。

## Path Follow アプリケーションの作成

深層学習アプリケーションを作成するときと同様に、`createcar` コマンドで **path_follow** テンプレートを指定してアプリケーションを作成できます。まず、donkeycar のPython環境が有効になっていることを確認し、**createcar** コマンドでアプリケーションフォルダを作成します。

```bash
donkey createcar --template=path_follow --path=~/mycar
```

Donkeycarを新しいバージョンに更新する際は、同じコマンドに `--overwrite` を追加してアプリケーションフォルダを更新します。これにより **myconfig.py** ファイルは削除されません。

```bash
donkey createcar --template=path_follow --path=~/mycar --overwrite
```

## 設定

ディープラーニングテンプレートと同様に、`createcar` コマンドで作成した **mycar** フォルダ内の **myconfig.py** を編集することでデフォルト設定値を変更できます。

[**Calibrate your Car**](/guide/calibrate/) の説明に従ってドライブトレインをキャリブレーションおよび設定する必要があります。ゲームコントローラを車にペアリングしている場合は、[Controllers](/parts/controllers) の説明に従って設定してください。

### GPSの設定
`myconfig.py` 内で 'gps' セクションを探します。`HAVE_GPS = True` が設定されていることを確認してください。GPSレシーバーが接続されているシリアルポートと使用するボーレートを決定する必要があります。可能であればシリアルポートのボーレートを `115200` に設定して、良好なスループットを得てください。

- `GPS_SERIAL = <serialport>`
    - `<serialport>` の値は、GPSレシーバーをUSB経由で接続しているかGPIOシリアルで接続しているか、またSBC（RPiかNano）によって異なります。
    - 利用可能なシリアルポートの一覧は `ls /dev/tty*` で確認できます。ただし、多くは実際には使用できません。
    - NanoのUSBポートに接続する場合は `/dev/ttyUSB0` を使用します。
    - RPiのUSBポートに接続する場合は `/dev/ttyACM01` を使用します。
    - RPiの標準GPIOシリアルポート（基板ピン8と10）に接続する場合は `/dev/ttyAMA0` を使用します。
    - Jetson Nanoの標準GPIOシリアルポート（基板ピン8と10）に接続する場合は `/dev/ttyTHS1` を使用します。
- `GPS_SERIAL_BAUDRATE = <baudrate>`
    - `<baudrate>` の値はGPSの種類やU-Centerで変更したかどうかによって異なります。
    - SBCのUSBポートとGPSレシーバーのUSBポートを接続する場合、ボーレートはUSBが自動検出するので115200を選んで高速接続にします。
    - ZED-F9Pの他のシリアルポートはデフォルトで38400ボーです。
    - 安価なGPSレシーバーは一般的に9600ボーがデフォルトです。
    - UBloxのU-CenterでGPSレシーバーのUARTボーレートを変更する方法は[この動画](https://youtu.be/GLtEtxPWoIk)を参照してください。

RPiとJetson Nanoのどちらも、デフォルトのGPIOシリアルポートがログインコンソールとして使用されている場合があります（シリアル“ターミナル”を接続してログインできます）。GPIOシリアルポートを使用する場合はログインコンソールを無効にする必要があります。詳細は[Writing to a serial port](https://ezward.github.io/gps/#writing-to-the-serial-port) を参照してください。

これら2つの設定だけが **myconfig.py** でGPSレシーバーに関連して設定する必要のある項目です。多くのGPSレシーバーはシリアルポートのボーレートや位置情報の送信頻度などを直接設定することもできます。理想的には位置情報の更新頻度はできるだけ速い方が良いですが、受信機によって上限が異なり、更新頻度と精度の間にはトレードオフがあります。U-Blox製のGPSレシーバーは [U-Blox U-Center](https://www.u-blox.com/en/product/u-center) ソフトウェアで設定できます。詳細は [Donkeycar Meets RTK GPS](https://ezward.github.io/gps/#u-center) のU-Centerセクションを参照してください。他のチップセットメーカーにもそれぞれのソフトウェアがありますので、使用しているGPSレシーバーのメーカーを確認してください。RTK高精度GPSを使用する場合は、Donkeycarの外でさらに多くの設定や配線が必要です。設定方法の一例については [Donkeycar meets RTK GPS](https://ezward.github.io/gps/#donkeycar-meets-rtk-gps) を参照してください。関連する[動画](https://youtu.be/q4T7kTaExTs?t=970)もあります。

### エンコーダーと運動学の設定
エンコーダーを使うと車両の速度だけでなく位置も推定できるため、屋内でもGPSの代わりに[Path Follow](/guide/path_follow/path_follow) テンプレートを使うことができます。これには `myconfig.py` でいくつかの設定が必要です。具体的にはホイール径、ホイールベース長、車軸長などの計測値を設定します。詳しくは [Odometer Software Setup](/parts/odometry#software-setup) を参照してください。

### ボタン操作の設定

[web controller](/guide/get_driving/#driving-with-web-controller) または [game controller](/guide/get_driving/#driving-with-physical-joystick-controller) のどちらかを使用できます。**myconfig.py** のボタン割り当てを編集することで、ゲームパッドのボタンまたはWeb UIのボタンにアクションを割り当てられます。ゲームパッドボタンの名称は設定したコントローラによって異なります（注: 1つのボタンは緊急停止用に予約されています。`python manage.py drive` コマンドで車を起動した際のコンソール出力を確認すると、どのボタンが割り当てられているか分かります）。Web UIで利用できる5つのボタンは `web/w1` から `web/w5` という名前です。`None` を割り当てたボタンは無視されます。

- `SAVE_PATH_BTN` はメモリ上の経路をファイルに保存するボタンです。
- `LOAD_PATH_BTN` はCSVファイルから経路を読み込んでメモリに再ロードするボタンです。
- `RESET_ORIGIN_BTN` は現在位置を原点として設定するボタンです。
- `ERASE_PATH_BTN` はメモリ上の経路を消去して原点をリセットするボタンです。
- `TOGGLE_RECORDING_BTN` は記録モードのオン／オフを切り替えるボタンです。Web UIにはあらかじめ割り当てられたボタンがあるため、Web UIを使う場合は `web/w*` のいずれかに割り当てる必要はありません。
- `INC_PID_D_BTN` はPIDのD定数を PID_D_DELTA だけ増やすボタンです。
- `DEC_PID_D_BTN` はPIDのD定数を -PID_D_DELTA だけ減らすボタンです。
- `INC_PID_P_BTN` はPIDのP定数を PID_P_DELTA だけ増やすボタンです。
- `DEC_PID_P_BTN` はPIDのP定数を -PID_P_DELTA だけ減らすボタンです。

## 経路の記録

アルゴリズムは、開始地点と終了地点が一致する連続した経路を走行することを前提としています。記録するウェイポイント間の間隔は **myconfig.py** の `PATH_MIN_DIST` で調整できます。保存するファイル名や保存場所は `PATH_FILENAME` を編集して変更できます。

経路を記録する手順は以下の通りです。

- [web controller](/guide/get_driving/#driving-with-web-controller) または [game controller](/guide/get_driving/#driving-with-physical-joystick-controller) を使って **User** ドライブモードに入ります。
- 車を開始したい位置に移動します。
- メモリ上の経路を消去します（これにより原点もリセットされます）。
- 記録をオンにします。
- 車を手動で走らせ、再び開始地点に戻ってきます。
- 記録をオフにします。
- 必要であれば経路を保存します。

経路はカンマ区切り値 (.csv) ファイルとして保存されます。各行にはコンマで区切られた3つの数値、x座標・y座標・スロットルが含まれます。x座標とy座標は位置を読み取った時点の車の位置で、スロットルはその時点で有効だったスロットル値です。参考までに経路ファイルの一部を示します。
```
0.0033510593930259347, 7.996719985734671, 0.14
0.11206169077195227, 9.325505392625928, 0.16
0.20344207028392702, 10.525161047000438, 0.18
0.311049185693264, 11.724678185302764, 0.14
0.23874327179510146, 12.75951695209369, 0.13
0.26568955020047724, 14.015127370599657, 0.15
0.35580877534812316, 15.06704786233604, 0.18
0.4303318051388487, 16.192974457982928, 0.15
0.2126157897291705, 17.302927474025637, 0.17
-0.37973403913201764, 18.24986434960738, 0.17
-1.2822835729457438, 18.97783037694171, 0.17
-2.4313870034529828, 19.338536370545626, 0.17
-3.633584696042817, 19.182584955357015, 0.17
-4.694471199880354, 18.471380048431456, 0.25
-5.2241318183369, 17.256997687276453, 0.25
-5.462499356712215, 15.947787401732057, 0.25
-5.5869644057238474, 14.674541235901415, 0.25
```

経路は単純なCSVファイルとして保存されるため、多くのツールで可視化できます。経路を可視化する簡単な方法として [CSV Plot](https://csvplot.com) があります。右上（ホームボタンのすぐ左）のボタンを押して軸のスケールを正方形にすると良いでしょう。次に示すのは例として少し回転させた経路です。

![A CSV Path plotted in https://csvplot.com](../../assets/path_8_rotate.png)

## 経路の追従

現在の自動操縦は一定のスロットル値を使用します。これは **myconfig.py** の `PID_THROTTLE` を編集することで設定できます。

経路を追従する手順は以下の通りです。

- [web controller](/guide/get_driving/#driving-with-web-controller) または [game controller](/guide/get_driving/#driving-with-physical-joystick-controller) を使って **User** ドライブモードに入ります。
- 車を開始したい位置に移動します。
- 保存した経路を使用する場合は、その経路をメモリに読み込みます。
- 原点をリセットします（注意: 経路を消去せず、原点だけをリセットします）。
- **Autosteering** もしくは **Autopilot** ドライブモードに入ります。**Autosteering** モードでは車を動かすために手動でスロットルを入れる必要があります。**Autopilot** モードでは完全に自律走行するはずです。
- 車を止めるには再び **User** モードに入ります。

## Path Follow アルゴリズム

経路追従に使用するアルゴリズムは非常に単純で、いわばパスフォローのHello Worldです。

- 車両の現在のGPS位置を取得します。
- ウェイポイントリストの中から最も近いポイントを探します。最後に最も近かったウェイポイントから開始し、`PATH_SEARCH_LENGTH` 個先まで検索して現在位置に最も近いウェイポイントを選びます。
- 経路上でその最も近いポイントから `PATH_LOOK_AHEAD` 個先のウェイポイントを選びます。
- 同様に `PATH_LOOK_BEHIND` 個前のウェイポイントを選びます。
- 前後のウェイポイントを使って、目標とする走行ラインを表す直線を作成します。
- 車両の現在位置とその直線との間のクロストラック誤差を計算します。クロストラック誤差は直線からの距離と、どちら側にいるかを示す符号付きの値です。
- このクロストラック誤差をステアリングを制御するPIDコントローラの誤差入力として使用します。
- PIDコントローラが新しいステアリング値を出力します。

ステアリングに加えて、パスフォローコントローラは経路上で最も近いポイントに保存されているスロットル値に `myconfig.py` の `PID_THROTTLE` を掛けた値をスロットルとして設定します。`myconfig.py` で `USE_CONSTANT_THROTTLE = True` にしている場合はこの設定を上書きし、`PID_THROTTLE` を一定スロットルとして使用します。

### Path Follow パラメータの設定

このアルゴリズムは、目標となる直線と車両の測定位置とのクロストラック誤差を使ってどれくらい、どちらに舵を切るかを決定します。しかし記録した経路は単純な直線ではなく、多くの場合は何らかの周回コースです。前述のとおり、車両の現在位置を用いて経路の短い区間を選び、それを目標ラインとして使います。この短い区間は新しい位置が測定されるたびに再計算されます。どの2点を使って目標ラインを計算するかは、いくつかの設定パラメータで決まります。
```python
PATH_SEARCH_LENGTH = None   # 最も近いポイントを探す際に検索するポイント数。Noneなら全経路を検索
PATH_LOOK_AHEAD = 1         # 最も近いポイントから先に含めるポイント数
PATH_LOOK_BEHIND = 1        # 最も近いポイントから後ろに含めるポイント数
```

非常に高速で走行する場合は、低速走行時よりも先を見るポイント数を多くした方が、ステアリングが先のカーブを予測しやすくなります。look behind や look ahead を増やしてトラックラインを長くすると、ノイズフィルタの役割も果たし、ラインが滑らかになります。これによりコントローラのジッターが減ります。ただし、実際のカーブ形状とのバランスを取る必要があります。トラックセグメントが長すぎるとカーブを“平坦化”してしまい、カーブで十分に曲がれないアンダーステアの原因になります。

### PIDコントローラとは？

PIDコントローラは目標値と現在測定値の2つを受け取り、その誤差から目標値を達成するための制御値を計算する関数です（誤差をゼロに近づけるための値を出力します）。

ここでは目標ライン上を走ることが目的なので、クロストラック誤差（目標ラインと車両の測定位置との距離）がゼロになるようにします。PIDコントローラの出力は車両を目標ラインに近づけるためのステアリング値となります。つまり、車が目標ラインのどちら側にどれだけ離れているかに基づいてステアリングを制御するわけです。

アルゴリズムではクロストラック誤差の符号を用いてステアリングの向きを決めます。クロストラック誤差が車両が目標ラインの左側にいることを示す場合、車は目標ラインに向かって右に曲がるべきです。逆に右側にいる場合は左に曲がるべきです。車が目標ライン上にいる場合、ステアリングはニュートラルになります。

ではどれくらい舵を切るべきでしょうか。PIDコントローラはクロストラック誤差の大きさに比例したステアリング値を出力します。目標ラインに近い場合はわずかに舵を切り、ラインから大きく外れている場合は大きく曲がります。

### PID係数の決定

PID係数は最も重要で（そして時間のかかる）設定項目です。これらが車に合っていないと経路をうまくたどれません。係数は **myconfig.py** の値を編集して変更できます。

- `PID_P` は比例係数で、クロストラック誤差に掛けられます。最も重要なパラメータで、出力ステアリング値に最も寄与し、場合によってはこれだけでラインを追従できることもあります。値が小さすぎるとカーブで十分に曲がれず、大きすぎると経路の小さな変化に過剰反応してしまい、特にカーブでは車が円を描くように回り始めることがあります。
- `PID_D` は微分係数で、クロストラック誤差の変化量に掛けられます。振動やオーバーシュートを抑えるのに有用です。
- `PID_I` は積分係数で、クロストラック誤差の累積値に掛けられます。例えば片方のタイヤ径がわずかに違う場合など、累積誤差によるオフセットを減らすのに役立つかもしれません。

上の[ボタン操作の設定](#configure-button-actions)で述べたように、`INC_PID_P_BTN` や `DEC_PID_P_BTN` のような関数をゲームコントローラやWeb UIのボタンに割り当てて、走行中にPIDパラメータを変更することもできます。これにより、myconfig.py を編集して車を再起動することなく値を調整できるため、最適な係数を探す際に役立ちます。

PID係数を決定するのは難しい作業です。ひとつの手順を示します。

- まずP係数を決めます。
    - D係数とI係数をゼロにします。
    - 録音した直線を概ねたどれる値を、二分探索のようにして見つけます。おそらくその直線を中心に蛇行します。酔っ払ったようにふらつくかもしれません。
    - これを行うには、長さ6メートル程度の短い直線を記録します。車を記録モードにして歩きながら（スロットルはゼロのまま）記録できます。短い直線を記録したら車をオートパイロットモードにし、ラインの中央に立って車をラインと平行に保持します。車の前輪は安定してまっすぐのままになるはずです。今度は車をゆっくりラインから外し、車体をラインと平行に保ったままにします。ラインから離れるほど車はラインに戻ろうと曲がり始めるはずです。両側で試してみてください。
        - ラインに戻るのではなく離れる方向に曲がる場合は、P値の符号を反転させます。
        - ほとんど曲がらない場合はP値を増やします。
        - ラインから外したときに急激に曲がる場合はP値を減らします。
        - P値を調整し、ラインから離れた量に比例して滑らかにラインへ戻るようにします。
        - その後、実際にオートパイロットモードでその直線を走らせてみます。車がラインの周りで振動するかもしれません。振動が激しい場合はP値を下げます。P値を調整して、直線を端から端まで走れるようにします。直線の終端ではおそらく制御不能になりますが、これは経路が閉じていないためで正常です。
        - 短い直線を走れるようになったら、P値だけ設定した状態で閉じた経路をオートパイロットで走らせます。経路にはかなりきついカーブを含めてください。P値を調整して満足できる走行を得られるようにします。これができたらD値でさらに調整します。
- 次に、直線走行時の蛇行（振動）を減らすD係数を見つけます。その後、きついカーブを含む経路を記録し、曲がる際のオーバーシュートを減らすD値を探します。
- I値は必要ないかもしれません。長時間走行すると車が不安定になる場合は、この値を設定し始めるとよいでしょう。他の値よりもかなり小さくなるはずです。

焦らずに進めましょう。まずは比較的遅い速度から始めます。1回に1つだけ変更してテストし、同時に多数の変更を行わないでください。うまくいったことはメモしておきます。

安定したPIDコントローラが得られたら、オートパイロットが不安定になる前にどれくらいの速度まで出せるかを把握できます。さらに速く走りたい場合は、希望の速度に設定して、上記の方法で再び値を調整してみてください。
