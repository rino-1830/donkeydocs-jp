# Keras で自動運転を学習する

これで安定して車を走らせられるようになったら、[Keras](https://keras.io/) を使ってあなたの走り方を学習するニューラルネットワークを作成できます。以下が手順です。

## データ収集

良質なクリーンデータを収集することを忘れないでください。ニューラルネットワークは与えられたデータから学習するため、質の悪いデータからは質の悪いモデルしか得られません。走行中にコースアウトした区間があると、学習したモデルにもその要素が反映されてしまいます。理想としては完璧な走行で不要なデータを記録しないことですが、現実的ではありません。ただし発生したエラーを簡単に取り除く方法はあります。

ミスをしたときにコントローラーの erase-records ボタンを使用すると、悪いデータの収集を避けるのに役立ちます。クラッシュしたらすぐに録画をオフに切り替え、erase-records ボタンを押して直近 100 件の記録を削除しましょう。`myconfig.py` で `AUTO_RECORD_ON_THROTTLE = True` に設定しておくとさらに簡単で、スロットルを入れると記録が開始され、スロットルを戻すと自動で停止します。この設定と erase-records ボタンを組み合わせれば、`donkey tubclean` コマンドでデータを後からクリーンアップする必要なく、数万件の記録を集められます。

実際のミスだけでなく、記録するデータの一貫性も重要です。データのばらつきが大きいほど、良いモデルを得るにはより多くのデータが必要になります。走行が安定していればいるほどデータが均一となり、ニューラルネットワークは入力と出力の関係をより効果的に学習できます。特にスロットルは再現が難しく、コース上の同じ場所でまったく同じスロットルを入力するのは非常に困難です。私が実践している方法の一つは、コース全体あるいは大部分を維持できる最大スロットルを見つけ、それだけを使用することです。`myconfig.py` の `JOYSTICK_MAX_THROTTLE` をその値に設定すれば、データ収集時にほとんどの区間で全開にできます。


1. まずはコースを数周走行して練習しましょう。
2. ミスなく 10 周程度走れる自信が付いたら、`python manage.py` プロセスを再起動して新しいデータ記録セッションを作成します。Web コントローラーを使用している場合は「Start Recording」を押すか、前述の `AUTO_RECORD_ON_THROTTLE = True` を使ってジョイスティックのスロットル操作で自動記録するようにします。
3. クラッシュしたりコースアウトしたら直ちに Stop Car を押して記録を停止します。ジョイスティックを使っている場合は、最後の 100 件（20Hz のドライブループで 5 秒分）の記録を消去するボタンを押します。
4. 良いデータを 10～20 周（5～20k 画像）収集できたら、車の ssh セッションで `Ctrl-c` を押して終了します。
5. 収集したデータは mycar の data フォルダーに保存されています。
6. ミスを記録してしまった場合は `donkey tubclean` を使ってデータを編集し、不要な部分を削除します。

## 車から PC へデータ転送

Raspberry Pi では処理能力が低いため、データを PC に転送して学習させる必要があります。Jetson Nano なら多少高速ですが、それでも学習はかなり遅いです。望むならこの転送手順を省き、Nano 上で学習しても構いません。

## GUI を使った簡単な学習方法

デスクトップで最も簡単に学習する方法は、[Donkey UI アプリケーション](/utility/ui) を利用することです。
 ![Tub_manager UI](/assets/ui-tub-manager.png)

それでもコマンドラインで学習したい場合は、この先を読んでください…。

## コマンドラインで学習する

ホスト PC の新しいターミナルセッションで rsync を使用し、Raspberry Pi から車のフォルダーをコピーします。

```bash
rsync -rv --progress --partial pi@<your_pi_ip_address>:~/mycar/data/  ~/mycar/data/
```

## モデルを学習させる

* 同じターミナルで、取得した最新データに対して学習スクリプトを実行します。引数としてデータへのパスを指定します。`./data/*` のようにパスのマスクを指定すれば複数のマニフェストをまとめて扱えます。例として、ホスト PC の mycar フォルダーで以下を実行します。

```bash
~\mycar$ donkey train --tub ./data --model ./models/mypilot.h5
```
カンマ区切りリスト `--tub=foo/data,bar/data` あるいはスペース区切り `--tub foo/data bar/data` で複数の tub を指定できます。詳しくは[Train the Model](/utility/donkey#train-the-model) を参照してください。

* `--type` 引数を使うことで異なるモデルタイプを作成できます。また `myconfig.py` の `DEFAULT_MODEL_TYPE` でデフォルトのモデルタイプを変更することも可能です。新しいモデルタイプを指定する場合、モデルを実行するときやプロット・プロファイルなど他のツールで使用する際にもそのタイプを指定してください。各モデルタイプの詳細は [Keras Parts](/parts/keras) を参照してください。学習したモデルは `models/` フォルダーに保存されます。`--model` フラグを省略すると、`pilot_YY-MM-DD_N.h5` というパターンで自動的に名前が付けられます。

* バージョン 4.3.0 以降では、tflite 形式のモデルが自動生成され、高速推論用に `./models/mypilot.tflite` も作成されます。tflite の生成を抑止したい場合は `myconfig.py` で `CREATE_TF_LITE = False` に設定します。さらに `CREATE_TENSOR_RT = True` を設定すると（デフォルトは `False`）、TensorRT モデル `./models/mypilot.trt` も生成されます。このファイルはすべてのプラットフォームで動作するはずです。RPi では tflite モデルが最速です。

> **注記:** 4.2 では回帰があり、`--model mypilot.h5` のようにモデル名だけを指定できていましたが、これは 4.2.1 で修正されました。ぜひアップデートしてください。

* **画像拡張** バージョン 4.3.0 以降では、学習時に画像拡張を利用できます。画像拡張とは画像データを変化させ（拡張し）、データにバリエーションを持たせる手法です。目的は二つあり、一つはデータ量が少ない場合に補うこと、もう一つは推論時のデータ変動に強いモデルを作ることです。ここではさまざまな照明条件に対応できるようにすることが狙いです。設定の `AUGMENTATIONS = ['MULTIPLY', 'BLUR']` で明るさ調整とガウシアンブラーを適用できます。個別にも併用も可能です。拡張は学習時のみ適用され、オートパイロット走行時には適用されません。

* **画像変換** バージョン 4.3.0 以降では、クロッピングや台形マスクなどの画像変換も利用できます。**クロッピングとマスキング** は似ており、いずれも画像のピクセルを「消す」ことで、重要でないピクセルや条件によって変化しやすい詳細部分を除去し、モデルの性能低下を防ぎます。クロッピングでは画像の上・下・左・右を削ることができ、台形マスクでは遠近を考慮した台形状のマスクで柔軟にピクセルを無効化できます。画像をクロップまたは台形マスクするには `TRANSFORMATIONS = ['CROP']` か `TRANSFORMATIONS = ['TRAPEZE']` を設定します。通常どちらか一方のみを使用します。**変換は学習時とオートパイロット走行時で同じ方法を適用する必要があります**。学習用 PC と Donkey Car の双方で変換設定が一致していることを確認してください。

## モデルを車にコピー

* 前の手順でデータからモデルを学習しました。次はそのモデルを Raspberry Pi に戻し、実際に自走できるかテストします。

* 再び rsync を使って学習済みモデルを車へコピーします。

```bash
rsync -rv --progress --partial ~/mycar/models/ pi@<your_ip_address>:~/mycar/models/
```

* 走行準備ができるよう、車をコース上に置きます。

* これで再び車を起動し、モデルを渡して走行させます。

```bash
python manage.py drive --model ~/mycar/models/mypilot.h5
```

* ただし tflite モデルから始めたほうがより良い性能が得られます。

```bash
python manage.py drive --model ~/mycar/models/mypilot.tflite --type tflite_linear
```

* これで車が自動で走り始めるはずです。おめでとうございます！

## 【オプション】Jetson Nano で TensorRT を使用する

詳細は[こちら](/docs/guide/robot_sbc/tensorrt_jetson_nano.md)を参照してください。

## 学習のヒント

<iframe width="560" height="315" src="https://www.youtube.com/embed/4fXbDf_QWM4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

----

1. **Mode & Pilot**: ここまで進めたことを祝福します。上記のコマンドを実行した後、Mode & Pilot メニューのオプションを確認してください。少しわかりにくいので各オプションの意味を説明します。

  a. **User** : その名の通り、ステアリングもスロットルもあなたが操作します。

  b. **Local Angle** : 少し分かりにくいですが、ここでは学習済みモデル（上で作成した mypilot）がステアリングを制御します。_Local_ とは Raspberry Pi 上に置かれた学習モデルを指します。

  c. **Local Pilot** : 学習済みモデル（mypilot）がステアリングとスロットルの両方を制御します。現時点ではあまり信頼性が高くないとされています。

  **Max Throttle** と **Throttle Mode** の各オプションも確認し、いろいろ設定を試してください。学習に大きく役立つ場合があります。

2. **シンプルなコースを作る** : あまり文書化されていませんが、理論上この車はどんなコースでも学習できるはずです。まずは中央線のある二車線コースを作る必要はないかもしれません。中央線のない一車線や、周回する一本のラインだけでも試してみましょう。最低限、エンドツーエンドのテストを行ってソフトウェアのパイプラインが正常に動作しているか確認できます。もちろん次のステップとして、より一般的なコースを作って[近くの meetup](https://diyrobocars.com/local-meetup-groups/) に参加してみてください。

3. **助けを得る** : 友人に手伝ってもらいましょう。コース作りは見た目より大変なので、数人いると非常に助かります。また、テープの代わりに[リボン](https://www.amazon.com/gp/product/B00L2MLCNO)を使うと資材（とテープ）を節約できます。固定には少しテープが必要ですが、再利用できて敷くのもずっと楽です（屋外で作業する場合は風で最初が少し大変かもしれません）。

## 振る舞いモデルの学習

<iframe width="560" height="315" src="https://www.youtube.com/embed/aLFuHGlU0CM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

----

### 振る舞いモデルの学習方法

 * 学習時およびロボットで実行するときは myconfig.py の `TRAIN_BEHAVIORS = True` を確認してください。

* ロボットに RGB LED を取り付け、どの状態がアクティブか示すようにします。config.py で有効にし、ロボットを実行中に L1 PS3 ボタン（左上のショルダーボタン）を押すと状態表示 LED が変わるか確認します。

* デフォルトでは状態は 2 つです。必要に応じて config.py の末尾で状態数を変更してください。`BEHAVIOR_LIST` を任意のラベル数に変更し、`BEHAVIOR_LED_COLORS` の RGB カラーも同数用意します。変更内容は PC とロボットの両方で反映させてください。

* 学習では L1 ショルダーボタンで任意の状態をアクティブにし、その状態で走らせたい走行を行います。状態を切り替えたら新しい定常状態へ移行します。

* 二車線の場合は、片側 33%、もう片側 33%、そして残り 33% をレーン変更中として走行します。レーンを変える前に状態遷移をトリガーすることが重要です。

* データファイル内の記録を確認します。.json を開くとステアリングやスロットルに加えて、振る舞いベクトルやそのフレームでどの状態がアクティブだったかが追加されているはずです。これが正しく学習するために重要です。

* データを PC に移動し、通常どおり学習します。その際 PC 側の myconfig.py でも `TRAIN_BEHAVIORS = True` になっていることを確認してください。そうでないと追加の状態情報が無視されてしまいます。

* 学習したモデルをロボットに戻します。初期状態の場所にロボットを置き、以下のようにモデルを指定して起動します。

```bash
python manage.py drive --model=models/my_beh.h5 --type=behavior
```

* Select ボタンを押すと目的の AI モードに切り替えられます。一定スロットルも学習したスロットルも利用可能です。

走行中に L1 を押すと状態を切り替え、どれだけ学習した定常状態や遷移を再現できるか確かめられます。

状態間の遷移例を多く含めるようにしてください。最低でも 50 回、できれば 100 回ほど行いましょう。